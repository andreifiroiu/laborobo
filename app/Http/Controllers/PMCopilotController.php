<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Agents\Workflows\PMCopilotWorkflow;
use App\Http\Requests\ApproveSuggestionRequest;
use App\Http\Requests\RejectSuggestionRequest;
use App\Http\Requests\TriggerPMCopilotRequest;
use App\Models\AgentWorkflowState;
use App\Models\AIAgent;
use App\Models\InboxItem;
use App\Models\Project;
use App\Models\Task;
use App\Models\WorkOrder;
use App\Services\AgentApprovalService;
use App\Services\AgentOrchestrator;
use App\Services\AgentRunner;
use App\Services\ProjectInsightsService;
use App\Services\TaskDelegationService;
use App\ValueObjects\DeliverableSuggestion;
use App\ValueObjects\TaskSuggestion;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;

/**
 * Controller for PM Copilot AI agent functionality.
 *
 * Handles triggering PM Copilot workflows, retrieving suggestions,
 * and processing approval/rejection of generated deliverables and tasks.
 */
class PMCopilotController extends Controller
{
    public function __construct(
        private readonly AgentOrchestrator $orchestrator,
        private readonly AgentApprovalService $approvalService,
        private readonly AgentRunner $agentRunner,
    ) {}

    /**
     * Start PM Copilot workflow for a work order.
     *
     * Creates and initiates a PMCopilotWorkflow to analyze the work order
     * and generate deliverable and task suggestions.
     */
    public function trigger(TriggerPMCopilotRequest $request, WorkOrder $workOrder): JsonResponse
    {
        $this->authorize('view', $workOrder);

        try {
            // Create the workflow state
            $workflowState = $this->orchestrator->invokePMCopilot($workOrder);

            Log::info('PM Copilot triggered via API', [
                'work_order_id' => $workOrder->id,
                'workflow_state_id' => $workflowState->id,
                'user_id' => $request->user()->id,
            ]);

            // Try to run the workflow, but don't fail if it encounters issues
            $status = 'started';
            try {
                $workflow = new PMCopilotWorkflow($this->orchestrator, $this->approvalService, $this->agentRunner);
                $workflow->setCurrentState($workflowState);
                $workflow->run();

                $workflowState->refresh();
                $status = $workflowState->isCompleted() ? 'completed' : ($workflowState->isPaused() ? 'paused' : 'running');
            } catch (\Throwable $workflowError) {
                Log::warning('PM Copilot workflow execution encountered an error', [
                    'work_order_id' => $workOrder->id,
                    'workflow_state_id' => $workflowState->id,
                    'error' => $workflowError->getMessage(),
                ]);

                return response()->json([
                    'success' => false,
                    'message' => 'PM Copilot workflow failed: '.$workflowError->getMessage(),
                    'error' => $workflowError->getMessage(),
                    'workflow_state_id' => $workflowState->id,
                    'status' => 'error',
                ], 500);
            }

            return response()->json([
                'success' => true,
                'message' => 'PM Copilot workflow completed',
                'workflow_state_id' => $workflowState->id,
                'status' => $status,
            ]);
        } catch (\Throwable $e) {
            Log::error('PM Copilot trigger failed', [
                'work_order_id' => $workOrder->id,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);

            return response()->json([
                'success' => false,
                'message' => 'Failed to start PM Copilot workflow',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Get generated suggestions for a work order.
     *
     * Returns deliverable and task suggestions generated by the PM Copilot
     * workflow for review and approval.
     */
    public function getSuggestions(WorkOrder $workOrder): JsonResponse
    {
        $this->authorize('view', $workOrder);

        // Find the most recent workflow state for this work order
        $workflowState = AgentWorkflowState::query()
            ->where('workflow_class', PMCopilotWorkflow::class)
            ->whereJsonContains('state_data->input->work_order_id', $workOrder->id)
            ->latest()
            ->first();

        if ($workflowState === null) {
            return response()->json([
                'success' => false,
                'message' => 'No PM Copilot workflow found for this work order',
                'alternatives' => [],
                'insights' => [],
            ], 404);
        }

        $stateData = $workflowState->state_data ?? [];
        $deliverableAlternatives = $stateData['deliverable_alternatives'] ?? [];
        $taskBreakdown = $stateData['task_breakdown'] ?? [];
        $insights = $stateData['insights'] ?? [];

        // Map task breakdown by deliverable title for merging into alternatives
        $tasksByDeliverable = [];
        foreach ($taskBreakdown as $breakdown) {
            $deliverableTitle = $breakdown['deliverable_title'] ?? '';
            $tasksByDeliverable[$deliverableTitle] = $breakdown['tasks'] ?? [];
        }

        // Transform workflow state into the frontend PlanAlternative shape
        $alternatives = array_map(function (array $alt) use ($tasksByDeliverable) {
            $deliverables = $alt['deliverables'] ?? [];

            // Collect tasks for all deliverables in this alternative
            $tasks = [];
            foreach ($deliverables as $deliverable) {
                $title = $deliverable['title'] ?? '';
                if (isset($tasksByDeliverable[$title])) {
                    $tasks = array_merge($tasks, $tasksByDeliverable[$title]);
                }
            }

            return [
                'id' => (string) ($alt['alternative_id'] ?? ''),
                'name' => $alt['name'] ?? 'Untitled',
                'description' => $alt['reasoning'] ?? '',
                'confidence' => $alt['confidence'] ?? 'medium',
                'deliverables' => array_map(fn (array $d) => [
                    'id' => md5($d['title'] ?? ''),
                    'title' => $d['title'] ?? '',
                    'description' => $d['description'] ?? '',
                    'type' => $d['type'] ?? 'other',
                    'acceptanceCriteria' => $d['acceptance_criteria'] ?? [],
                    'confidence' => $d['confidence'] ?? 'medium',
                ], $deliverables),
                'tasks' => array_map(fn (array $t) => [
                    'id' => md5($t['title'] ?? ''),
                    'title' => $t['title'] ?? '',
                    'description' => $t['description'] ?? '',
                    'estimatedHours' => $t['estimated_hours'] ?? 0,
                    'positionInWorkOrder' => $t['position_in_work_order'] ?? 0,
                    'checklistItems' => $t['checklist_items'] ?? [],
                    'dependencies' => array_map('strval', $t['dependencies'] ?? []),
                    'confidence' => $t['confidence'] ?? 'medium',
                ], $tasks),
            ];
        }, $deliverableAlternatives);

        $status = $workflowState->isCompleted() ? 'completed' : ($workflowState->isPaused() ? 'paused' : 'running');

        return response()->json([
            'success' => true,
            'workOrderId' => (string) $workOrder->id,
            'workflowState' => [
                'status' => $status,
                'currentStep' => $workflowState->current_node,
                'progress' => $status === 'completed' ? 100 : 50,
                'error' => null,
            ],
            'alternatives' => $alternatives,
            'approvedAlternativeId' => $stateData['approved_alternative_id'] ?? null,
            'insights' => $insights,
            'createdAt' => $workflowState->created_at?->toIso8601String() ?? '',
            'updatedAt' => $workflowState->updated_at?->toIso8601String() ?? '',
        ]);
    }

    /**
     * Approve a generated suggestion.
     *
     * Creates the approved deliverable or task from the suggestion
     * and marks the corresponding inbox item as approved.
     */
    public function approveSuggestion(ApproveSuggestionRequest $request, InboxItem $suggestion): JsonResponse
    {
        // Verify the inbox item belongs to user's team
        if ($suggestion->team_id !== $request->user()->currentTeam->id) {
            return response()->json([
                'success' => false,
                'message' => 'Unauthorized',
            ], 403);
        }

        $suggestionType = $request->validated('suggestion_type');
        $suggestionIndex = $request->validated('suggestion_index');

        // Get the workflow state associated with this inbox item
        /** @var AgentWorkflowState|null $workflowState */
        $workflowState = $suggestion->approvable;

        if ($workflowState === null || ! $workflowState instanceof AgentWorkflowState) {
            return response()->json([
                'success' => false,
                'message' => 'Invalid suggestion reference',
            ], 400);
        }

        $stateData = $workflowState->state_data ?? [];
        $workOrderId = $stateData['input']['work_order_id'] ?? null;

        if ($workOrderId === null) {
            return response()->json([
                'success' => false,
                'message' => 'Work order not found in workflow state',
            ], 400);
        }

        $workOrder = WorkOrder::find($workOrderId);

        if ($workOrder === null) {
            return response()->json([
                'success' => false,
                'message' => 'Work order not found',
            ], 404);
        }

        try {
            if ($suggestionType === 'deliverable') {
                $this->approveDeliverableSuggestion($workflowState, $suggestionIndex, $workOrder);
            } elseif ($suggestionType === 'task') {
                $this->approveTaskSuggestion($workflowState, $suggestionIndex, $workOrder);
            } else {
                return response()->json([
                    'success' => false,
                    'message' => 'Invalid suggestion type',
                ], 400);
            }

            // Mark the inbox item as approved
            $suggestion->markAsApproved();

            Log::info('PM Copilot suggestion approved', [
                'inbox_item_id' => $suggestion->id,
                'suggestion_type' => $suggestionType,
                'suggestion_index' => $suggestionIndex,
                'work_order_id' => $workOrderId,
                'user_id' => $request->user()->id,
            ]);

            return response()->json([
                'success' => true,
                'message' => 'Suggestion approved',
            ]);
        } catch (\Throwable $e) {
            Log::error('PM Copilot suggestion approval failed', [
                'inbox_item_id' => $suggestion->id,
                'error' => $e->getMessage(),
            ]);

            return response()->json([
                'success' => false,
                'message' => 'Failed to approve suggestion',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Reject a generated suggestion.
     *
     * Marks the suggestion as rejected with the provided reason
     * and updates the corresponding inbox item.
     */
    public function rejectSuggestion(RejectSuggestionRequest $request, InboxItem $suggestion): JsonResponse
    {
        // Verify the inbox item belongs to user's team
        if ($suggestion->team_id !== $request->user()->currentTeam->id) {
            return response()->json([
                'success' => false,
                'message' => 'Unauthorized',
            ], 403);
        }

        $suggestionType = $request->validated('suggestion_type');
        $suggestionIndex = $request->validated('suggestion_index');
        $reason = $request->validated('reason');

        // Get the workflow state associated with this inbox item
        /** @var AgentWorkflowState|null $workflowState */
        $workflowState = $suggestion->approvable;

        if ($workflowState === null || ! $workflowState instanceof AgentWorkflowState) {
            return response()->json([
                'success' => false,
                'message' => 'Invalid suggestion reference',
            ], 400);
        }

        try {
            // Update the workflow state with rejection info
            $stateData = $workflowState->state_data ?? [];

            if ($suggestionType === 'deliverable') {
                $stateData['rejected_deliverables'] = $stateData['rejected_deliverables'] ?? [];
                $stateData['rejected_deliverables'][] = [
                    'index' => $suggestionIndex,
                    'reason' => $reason,
                    'rejected_at' => now()->toIso8601String(),
                    'rejected_by' => $request->user()->id,
                ];
            } elseif ($suggestionType === 'task') {
                $stateData['rejected_tasks'] = $stateData['rejected_tasks'] ?? [];
                $stateData['rejected_tasks'][] = [
                    'index' => $suggestionIndex,
                    'reason' => $reason,
                    'rejected_at' => now()->toIso8601String(),
                    'rejected_by' => $request->user()->id,
                ];
            }

            $workflowState->update(['state_data' => $stateData]);

            // Mark the inbox item as rejected
            $suggestion->markAsRejected();

            Log::info('PM Copilot suggestion rejected', [
                'inbox_item_id' => $suggestion->id,
                'suggestion_type' => $suggestionType,
                'suggestion_index' => $suggestionIndex,
                'reason' => $reason,
                'user_id' => $request->user()->id,
            ]);

            return response()->json([
                'success' => true,
                'message' => 'Suggestion rejected',
            ]);
        } catch (\Throwable $e) {
            Log::error('PM Copilot suggestion rejection failed', [
                'inbox_item_id' => $suggestion->id,
                'error' => $e->getMessage(),
            ]);

            return response()->json([
                'success' => false,
                'message' => 'Failed to reject suggestion',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Get project insights generated by AI analysis.
     *
     * Returns insights about overdue items, bottlenecks, scope creep,
     * and resource reallocation suggestions for the project.
     */
    public function getProjectInsights(Project $project, ProjectInsightsService $insightsService): JsonResponse
    {
        $this->authorize('view', $project);

        try {
            $insights = $insightsService->generateInsights($project);

            return response()->json([
                'success' => true,
                'insights' => array_map(fn ($insight) => $insight->toArray(), $insights),
            ]);
        } catch (\Throwable $e) {
            Log::error('Failed to generate project insights', [
                'project_id' => $project->id,
                'error' => $e->getMessage(),
            ]);

            return response()->json([
                'success' => false,
                'message' => 'Failed to generate project insights',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Approve a plan alternative for a work order.
     *
     * Creates deliverables and tasks from the selected alternative
     * directly from the workflow state data.
     */
    public function approveAlternative(WorkOrder $workOrder, string $alternativeId): JsonResponse
    {
        $this->authorize('view', $workOrder);

        $workflowState = AgentWorkflowState::query()
            ->where('workflow_class', PMCopilotWorkflow::class)
            ->whereJsonContains('state_data->input->work_order_id', $workOrder->id)
            ->latest()
            ->first();

        if ($workflowState === null) {
            return response()->json([
                'success' => false,
                'message' => 'No PM Copilot workflow found for this work order',
            ], 404);
        }

        $stateData = $workflowState->state_data ?? [];
        $alternatives = $stateData['deliverable_alternatives'] ?? [];
        $taskBreakdown = $stateData['task_breakdown'] ?? [];

        // Find the matching alternative
        $alternative = null;
        foreach ($alternatives as $alt) {
            if ((string) ($alt['alternative_id'] ?? '') === $alternativeId) {
                $alternative = $alt;
                break;
            }
        }

        if ($alternative === null) {
            return response()->json([
                'success' => false,
                'message' => "Alternative {$alternativeId} not found",
            ], 404);
        }

        try {
            $createdDeliverables = 0;
            $createdTasks = 0;

            // Map task breakdown by deliverable title
            $tasksByDeliverable = [];
            foreach ($taskBreakdown as $breakdown) {
                $deliverableTitle = $breakdown['deliverable_title'] ?? '';
                $tasksByDeliverable[$deliverableTitle] = $breakdown['tasks'] ?? [];
            }

            // Create deliverables from this alternative
            foreach ($alternative['deliverables'] ?? [] as $deliverableData) {
                $suggestion = DeliverableSuggestion::fromArray($deliverableData);
                $suggestion->createDeliverable($workOrder);
                $createdDeliverables++;

                // Create tasks linked to this deliverable
                $deliverableTitle = $deliverableData['title'] ?? '';
                if (isset($tasksByDeliverable[$deliverableTitle])) {
                    foreach ($tasksByDeliverable[$deliverableTitle] as $taskData) {
                        $taskSuggestion = TaskSuggestion::fromArray($taskData);
                        $taskSuggestion->createTask($workOrder);
                        $createdTasks++;
                    }
                }
            }

            // Mark alternative as approved in state data
            $stateData['approved_alternative_id'] = $alternativeId;
            $stateData['approved_at'] = now()->toIso8601String();
            $workflowState->update(['state_data' => $stateData]);

            Log::info('PM Copilot alternative approved', [
                'work_order_id' => $workOrder->id,
                'alternative_id' => $alternativeId,
                'deliverables_created' => $createdDeliverables,
                'tasks_created' => $createdTasks,
            ]);

            return response()->json([
                'success' => true,
                'message' => "Alternative approved: {$createdDeliverables} deliverable(s) and {$createdTasks} task(s) created.",
                'deliverables_created' => $createdDeliverables,
                'tasks_created' => $createdTasks,
            ]);
        } catch (\Throwable $e) {
            Log::error('PM Copilot alternative approval failed', [
                'work_order_id' => $workOrder->id,
                'alternative_id' => $alternativeId,
                'error' => $e->getMessage(),
            ]);

            return response()->json([
                'success' => false,
                'message' => 'Failed to approve alternative',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Reject a plan alternative for a work order.
     */
    public function rejectAlternative(WorkOrder $workOrder, string $alternativeId): JsonResponse
    {
        $this->authorize('view', $workOrder);

        $workflowState = AgentWorkflowState::query()
            ->where('workflow_class', PMCopilotWorkflow::class)
            ->whereJsonContains('state_data->input->work_order_id', $workOrder->id)
            ->latest()
            ->first();

        if ($workflowState === null) {
            return response()->json([
                'success' => false,
                'message' => 'No PM Copilot workflow found for this work order',
            ], 404);
        }

        try {
            $stateData = $workflowState->state_data ?? [];
            $stateData['rejected_alternatives'] = $stateData['rejected_alternatives'] ?? [];
            $stateData['rejected_alternatives'][] = [
                'alternative_id' => $alternativeId,
                'reason' => request()->input('reason'),
                'rejected_at' => now()->toIso8601String(),
            ];
            $workflowState->update(['state_data' => $stateData]);

            Log::info('PM Copilot alternative rejected', [
                'work_order_id' => $workOrder->id,
                'alternative_id' => $alternativeId,
            ]);

            return response()->json([
                'success' => true,
                'message' => 'Alternative rejected',
            ]);
        } catch (\Throwable $e) {
            Log::error('PM Copilot alternative rejection failed', [
                'work_order_id' => $workOrder->id,
                'alternative_id' => $alternativeId,
                'error' => $e->getMessage(),
            ]);

            return response()->json([
                'success' => false,
                'message' => 'Failed to reject alternative',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Delegate plan tasks to AI for assignment suggestions.
     *
     * Uses LLM to analyze unassigned tasks and suggest optimal assignees
     * (AI agents or human team members). Returns suggestions for user review.
     */
    public function delegatePlan(Request $request, WorkOrder $workOrder, TaskDelegationService $delegationService): JsonResponse
    {
        $this->authorize('view', $workOrder);

        try {
            $tasks = $workOrder->tasks()
                ->whereNull('assigned_to_id')
                ->whereNull('assigned_agent_id')
                ->get();

            if ($tasks->isEmpty()) {
                return response()->json([
                    'success' => true,
                    'suggestions' => [],
                    'message' => 'No unassigned tasks to delegate',
                ]);
            }

            $teamId = $request->user()->currentTeam->id;
            $suggestions = $delegationService->delegateTasks($workOrder, $tasks, $teamId);

            return response()->json([
                'success' => true,
                'suggestions' => $suggestions,
            ]);
        } catch (\Throwable $e) {
            Log::error('PM Copilot delegation failed', [
                'work_order_id' => $workOrder->id,
                'error' => $e->getMessage(),
            ]);

            return response()->json([
                'success' => false,
                'message' => 'Failed to delegate tasks',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Assign a task to a user or AI agent.
     *
     * When assigned to an AI agent, automatically starts a TaskExecutionWorkflow.
     */
    public function assignTask(Request $request, WorkOrder $workOrder, Task $task, TaskDelegationService $delegationService): JsonResponse
    {
        $this->authorize('view', $workOrder);

        $validated = $request->validate([
            'assignee_type' => 'required|string|in:user,agent',
            'assignee_id' => 'required|integer',
        ]);

        // Verify task belongs to this work order
        if ($task->work_order_id !== $workOrder->id) {
            return response()->json([
                'success' => false,
                'message' => 'Task does not belong to this work order',
            ], 400);
        }

        try {
            $workflowStatus = null;

            if ($validated['assignee_type'] === 'user') {
                $task->update([
                    'assigned_to_id' => $validated['assignee_id'],
                    'assigned_agent_id' => null,
                ]);
            } else {
                $agent = AIAgent::findOrFail($validated['assignee_id']);
                $team = $request->user()->currentTeam;

                $task->update([
                    'assigned_agent_id' => $agent->id,
                    'assigned_to_id' => null,
                ]);

                $workflowState = $delegationService->startTaskExecution($task, $agent, $team);
                $workflowState->refresh();

                $workflowStatus = $workflowState->isCompleted() ? 'completed' : ($workflowState->isPaused() ? 'paused' : 'running');
            }

            return response()->json([
                'success' => true,
                'message' => 'Task assigned successfully',
                'workflow_status' => $workflowStatus,
            ]);
        } catch (\Throwable $e) {
            Log::error('Task assignment failed', [
                'work_order_id' => $workOrder->id,
                'task_id' => $task->id,
                'error' => $e->getMessage(),
            ]);

            return response()->json([
                'success' => false,
                'message' => 'Failed to assign task',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Approve and create a deliverable from suggestion.
     */
    private function approveDeliverableSuggestion(
        AgentWorkflowState $workflowState,
        int $suggestionIndex,
        WorkOrder $workOrder
    ): void {
        $stateData = $workflowState->state_data ?? [];
        $suggestions = $stateData['deliverable_suggestions'] ?? [];

        if (! isset($suggestions[$suggestionIndex])) {
            throw new \InvalidArgumentException("Deliverable suggestion at index {$suggestionIndex} not found");
        }

        $suggestionData = $suggestions[$suggestionIndex];
        $deliverableSuggestion = DeliverableSuggestion::fromArray($suggestionData);

        // Create the deliverable
        $deliverableSuggestion->createDeliverable($workOrder);

        // Mark this suggestion as approved in state data
        $stateData['approved_deliverables'] = $stateData['approved_deliverables'] ?? [];
        $stateData['approved_deliverables'][] = $suggestionIndex;
        $workflowState->update(['state_data' => $stateData]);
    }

    /**
     * Approve and create tasks from suggestion.
     */
    private function approveTaskSuggestion(
        AgentWorkflowState $workflowState,
        int $suggestionIndex,
        WorkOrder $workOrder
    ): void {
        $stateData = $workflowState->state_data ?? [];
        $suggestions = $stateData['task_suggestions'] ?? [];

        if (! isset($suggestions[$suggestionIndex])) {
            throw new \InvalidArgumentException("Task suggestion at index {$suggestionIndex} not found");
        }

        $suggestionData = $suggestions[$suggestionIndex];
        $tasks = $suggestionData['tasks'] ?? [];

        // Create each task in the suggestion
        foreach ($tasks as $taskData) {
            $taskSuggestion = TaskSuggestion::fromArray($taskData);
            $taskSuggestion->createTask($workOrder);
        }

        // Mark this suggestion as approved in state data
        $stateData['approved_tasks'] = $stateData['approved_tasks'] ?? [];
        $stateData['approved_tasks'][] = $suggestionIndex;
        $workflowState->update(['state_data' => $stateData]);
    }
}
